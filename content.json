{"meta":{"title":"Silence","subtitle":"","description":"关于Java技术、Spring的个人博客","author":"Greyson","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-04-17T14:54:26.472Z","updated":"2021-04-17T14:54:26.472Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Hi, I’m Greyson. Welcome to my blog site. I’m trying to produce some userful articles. Thanks."},{"title":"生活记录","date":"2021-04-17T15:09:15.245Z","updated":"2021-04-17T15:09:15.245Z","comments":true,"path":"life/index.html","permalink":"http://example.com/life/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-04-17T14:56:42.979Z","updated":"2021-04-17T14:56:42.979Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-04-17T14:58:35.326Z","updated":"2021-04-17T14:58:35.326Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-04-17T14:57:45.305Z","updated":"2021-04-17T14:57:45.305Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"剑指offer 27 —— 二叉树的镜像","date":"2021-04-17T13:29:07.535Z","updated":"2021-04-17T05:28:16.000Z","comments":true,"path":"2021/04/17/剑指offer 27 —— 二叉树的镜像/","link":"","permalink":"http://example.com/2021/04/17/%E5%89%91%E6%8C%87offer%2027%20%E2%80%94%E2%80%94%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/","excerpt":"","text":"剑指offer 27 —— 二叉树的镜像思路：递归 实现： 1234567891011121314151617class Solution &#123; public TreeNode mirrorTree(TreeNode root) &#123; if (root == null) &#123; return root; &#125; // 获取反转过的子树 TreeNode l = mirrorTree(root.left); TreeNode r = mirrorTree(root.right)&#x27; // 左右互换 root.left = r; root.right = l; return root; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"剑指Offer 3 —— 从尾到头打印链表","date":"2021-04-17T13:29:07.533Z","updated":"2021-04-17T05:28:16.000Z","comments":true,"path":"2021/04/17/剑指Offer 3 —— 从尾到头打印链表/","link":"","permalink":"http://example.com/2021/04/17/%E5%89%91%E6%8C%87Offer%203%20%E2%80%94%E2%80%94%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","excerpt":"","text":"剑指Offer 3 —— 从尾到头打印链表递归： 1","categories":[],"tags":[]},{"title":"Leetcode 13 三数之和","slug":"Leetcode 13 三数之和","date":"2021-04-17T13:22:36.000Z","updated":"2021-04-17T13:40:16.102Z","comments":true,"path":"2021/04/17/Leetcode 13 三数之和/","link":"","permalink":"http://example.com/2021/04/17/Leetcode%2013%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"思路： 一个Base+双指针 先排序，base先指向第一个数，left指向base之后的第一个数，right指向最后一个数，sum&gt;0，right向左移，sum&lt;0，left向右移，找出数num+left所指数=target-base；找到了则base右移，注意去重，即指针移动时跳过相等的数 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (nums == null || nums.length &lt;= 2) return res; int n = nums.length; int i = 0; Arrays.sort(nums); while (i &lt;= n - 2) &#123; int base = nums[i]; int left = i+1; int right = n-1; while (left &lt; right) &#123; int sum = base + nums[left] + nums[right]; if (sum == 0) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); list.add(base); list.add(nums[left]); list.add(nums[right]); res.add(list); left = moveRight(nums, left + 1); right = moveLeft(nums, right - 1); &#125; else if (sum &gt; 0) &#123; right = moveLeft(nums, right - 1); &#125; else &#123; left = moveRight(nums, left + 1); &#125; &#125; i = moveRight(nums, i + 1); &#125; return res; &#125; public int moveLeft(int[] nums, int right) &#123; while (right == nums.length - 1 || (right &gt;= 0 &amp;&amp; nums[right] == nums[right + 1])) &#123; right --; &#125; return right; &#125; public int moveRight(int[] nums, int left) &#123; while (left == 0 || (left &lt; nums.length &amp;&amp; nums[left] == nums[left - 1])) &#123; left ++; &#125; return left; &#125;&#125; 时间复杂度：O(N2)","categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 16 —— 最接近的三数之和","slug":"Leetcode 16 —— 最接近的三数之和","date":"2021-04-17T13:22:36.000Z","updated":"2021-04-17T13:40:47.328Z","comments":true,"path":"2021/04/17/Leetcode 16 —— 最接近的三数之和/","link":"","permalink":"http://example.com/2021/04/17/Leetcode%2016%20%E2%80%94%E2%80%94%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"12345678910111213141516171819202122class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return target; Arrays.sort(nums); // 目标值target与sum的差值 int delta = nums[0] + nums[1] + nums[2] - target; for (int i = 0; i &lt; nums.length - 2; i++) &#123; int start = i + 1; int end = nums.length -1; while (start &lt; end) &#123; int newdelta = nums[i] + nums[start] + nums[end] - target; if (newdelta == 0) return target; if (Math.abs(delta) &gt; Math.abs(newdelta)) &#123; delta = newdelta; &#125; if (newdelta &lt; 0) start ++; else end --; &#125; &#125; return target + delta; &#125;&#125;","categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 17 —— 电话号码的组合","slug":"Leetcode 17 —— 电话号码的组合","date":"2021-04-17T13:22:36.000Z","updated":"2021-04-17T13:39:19.291Z","comments":true,"path":"2021/04/17/Leetcode 17 —— 电话号码的组合/","link":"","permalink":"http://example.com/2021/04/17/Leetcode%2017%20%E2%80%94%E2%80%94%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E7%BB%84%E5%90%88/","excerpt":"","text":"深度优先 123456789101112131415161718192021222324252627282930public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; res = new LinkedList&lt;String&gt;(); if (digits == null || digits.length() == 0) return res; HashMap&lt;Character, char[]&gt; map = new HashMap&lt;Character, char[]&gt;(); map.put(&#x27;2&#x27;, new char[]&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;); map.put(&#x27;3&#x27;, new char[]&#123;&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;&#125;); map.put(&#x27;4&#x27;, new char[]&#123;&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;&#125;); map.put(&#x27;5&#x27;, new char[]&#123;&#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;&#125;); map.put(&#x27;6&#x27;, new char[]&#123;&#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;&#125;); map.put(&#x27;7&#x27;, new char[]&#123;&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;&#125;); map.put(&#x27;8&#x27;, new char[]&#123;&#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;&#125;); map.put(&#x27;9&#x27;, new char[]&#123;&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;&#125;); helper(&quot;&quot;, 0, digits, res, map); return res; &#125; public void helper(String cur, int curIndex, String digits, List&lt;String&gt; res, HashMap&lt;Character, char[]&gt; map) &#123; if (curIndex == digits.length()) &#123; res.add(cur); &#125; else &#123; char c = digits.charAt(curIndex); if (map.containsKey(c)) &#123; for (char ch: map.get(c)) &#123; helper(cur + ch, curIndex+1, digits, res, map); &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 19 —— 删除倒数第n个节点","slug":"Leetcode 19 —— 删除倒数第n个节点","date":"2021-04-17T13:22:36.000Z","updated":"2021-04-17T13:38:51.677Z","comments":true,"path":"2021/04/17/Leetcode 19 —— 删除倒数第n个节点/","link":"","permalink":"http://example.com/2021/04/17/Leetcode%2019%20%E2%80%94%E2%80%94%20%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"12345678910111213141516171819202122class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; for(int i = 0; i &lt;= n; i++) &#123; fast = fast.next; &#125; while (fast != null) &#123; slow = slow.next; fast = fast.next; &#125; slow.next = slow.next.next; return dummy.next; &#125;&#125;","categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 20 —— 有效的括号","slug":"Leetcode 20 —— 有效的括号","date":"2021-04-17T13:22:36.000Z","updated":"2021-04-17T13:38:25.575Z","comments":true,"path":"2021/04/17/Leetcode 20 —— 有效的括号/","link":"","permalink":"http://example.com/2021/04/17/Leetcode%2020%20%E2%80%94%E2%80%94%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","excerpt":"","text":"借助栈： 123456789101112131415161718192021class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; mark = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; // 左括号入栈 if (s.charAt(i) == &#x27;(&#x27; || s.charAt(i) == &#x27;[&#x27; || s.charAt(i) == &#x27;&#123;&#x27;) &#123; mark.push(s.charAt(i)); // 右括号出栈 &#125; else if (s.charAt(i) == &#x27;)&#x27; || s.charAt(i) == &#x27;]&#x27; || s.charAt(i) == &#x27;&#125;&#x27;) &#123; if (mark.isEmpty()) return false; char cur = mark.pop(); if (cur == &#x27;(&#x27; &amp;&amp; s.charAt(i) != &#x27;)&#x27;) return false; if (cur == &#x27;[&#x27; &amp;&amp; s.charAt(i) != &#x27;]&#x27;) return false; if (cur == &#x27;&#123;&#x27; &amp;&amp; s.charAt(i) != &#x27;&#125;&#x27;) return false; &#125; &#125; if (mark.isEmpty()) return true; return false; &#125;&#125;","categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 203 —— 链表中删除节点","slug":"Leetcode 203 —— 链表中删除节点","date":"2021-04-17T13:22:36.000Z","updated":"2021-04-17T13:35:00.894Z","comments":true,"path":"2021/04/17/Leetcode 203 —— 链表中删除节点/","link":"","permalink":"http://example.com/2021/04/17/Leetcode%20203%20%E2%80%94%E2%80%94%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/","excerpt":"","text":"思路设置一个哨兵节点dummy，dummy不存储数据，cur指针初始指向dummy节点，cur.next为真正的头节点。遍历链表，如果cur的后继结点（拿后继节点判断是因为如果删除cur节点会找不到前一段链表）等于指定val，则删除后继节点，如果不相等，则cur节点后移。遍历完成返回真正头节点。 Java实现1234567891011121314151617class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode dummy = new ListNode(0); ListNode cur = dummy; cur.next = head; while (cur != null &amp;&amp; cur.next != null) &#123; if (cur.next.val == val) &#123; cur.next = cur.next.next; &#125; else &#123; cur = cur.next; &#125; &#125; return dummy.next; &#125;&#125;","categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 206——翻转链表","slug":"Leetcode 206——翻转链表","date":"2021-04-17T13:22:36.000Z","updated":"2021-04-17T13:33:44.889Z","comments":true,"path":"2021/04/17/Leetcode 206——翻转链表/","link":"","permalink":"http://example.com/2021/04/17/Leetcode%20206%E2%80%94%E2%80%94%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof 思路首先设置一个cur指针作为当前节点指针，初始时指向头节点；另外设置一个pre指针保存当前节点的前驱，初始时为空；将当前节点的后继节点保存在temp中，当前节点指向其前驱节点，然后将pre指向当前节点cur，cur重置指向其后继；以上是一个循环过程，设置一个while循环遍历所有节点，遍历完成返回当前头节点pre。 Java实现1234567891011121314151617181920class Solution &#123; public ListNode reverseList(ListNode head) &#123; // 初始化pre、cur指针 ListNode pre = null; ListNode cur = head; // 循环逆置链表 while (cur != null) &#123; // temp暂存当前节点后继 ListNode temp = cur.next; // 当前节点指向前驱节点，即指针逆置 cur.next = pre; // 指针重新置位：pre指向当前节点，cur指向当前节点的后继 pre = cur; cur = temp; &#125; // 逆置完成，返回头节点pre return pre; &#125;&#125;","categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 22 —— 括号生成","slug":"Leetcode 22 —— 括号生成","date":"2021-04-17T13:22:36.000Z","updated":"2021-04-17T13:37:22.258Z","comments":true,"path":"2021/04/17/Leetcode 22 —— 括号生成/","link":"","permalink":"http://example.com/2021/04/17/Leetcode%2022%20%E2%80%94%E2%80%94%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","excerpt":"","text":"思路： 回溯 实现： 12345678910111213141516171819202122232425class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; // res记录结果 List&lt;String&gt; res = new LinkedList&lt;String&gt;(); helper(&quot;&quot;, res, n, 0, 0); return res; &#125; // cur传入当前String状态、left是已有左括号，right是已有右括号 public void helper(String cur, List&lt;String&gt; res, int n, int left, int right) &#123; // 右括号等于给定数n，则返回List if (right == n) &#123; res.add(cur); return; &#125; // 左括号少于n个，可以添加左括号 if (left &lt; n) &#123; helper(cur + &quot;(&quot;, res, n, left + 1, right); &#125; // 右括号少于左括号，可以添加右括号 if (right &lt; left) &#123; helper(cur + &quot;)&quot;, res, n, left, right + 1 ); &#125; &#125;&#125;","categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 21—— 合并两个有序链表","slug":"Leetcode 21—— 合并两个有序链表","date":"2021-04-17T13:22:36.000Z","updated":"2021-04-17T13:37:54.492Z","comments":true,"path":"2021/04/17/Leetcode 21—— 合并两个有序链表/","link":"","permalink":"http://example.com/2021/04/17/Leetcode%2021%E2%80%94%E2%80%94%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","excerpt":"","text":"123456789101112131415161718192021222324252627class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; // 设置虚拟节点 ListNode dummy = new ListNode(0); ListNode cur = dummy; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt; l2.val) &#123; cur.next = l1; cur = cur.next; l1 = l1.next; &#125; else &#123; cur.next = l2; cur = cur.next; l2 = l2.next; &#125; &#125; if (l1 != null ) &#123; cur.next = l1; &#125; else &#123; cur.next = l2; &#125; return dummy.next; &#125;&#125;","categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 82 —— 删除排序链表中的重复元素II","slug":"Leetcode 82 —— 删除排序链表中的重复元素II","date":"2021-04-17T13:22:36.000Z","updated":"2021-04-17T13:36:40.656Z","comments":true,"path":"2021/04/17/Leetcode 82 —— 删除排序链表中的重复元素II/","link":"","permalink":"http://example.com/2021/04/17/Leetcode%2082%20%E2%80%94%E2%80%94%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/","excerpt":"","text":"题目：给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii 思路双指针法： 设置cur指针遍历操作找到相同元素，pre指针在cur前面进行删除操作； 因为要删除所有相同元素，所以要考虑到第一个节点和第二个节点就已经重复的情况，那么需要在传入的链表前设置一个虚拟节点dummy，也就是常说的哨兵节点。 分情况处理链表不同的情况： 两个不同节点之间没有重复节点：只需要移动pre指针 两个不同节点之间含有多个重复节点（大于等于两个）：cur指针需要多次移动跨过相同节点，pre指针指向cur所指节点 Java实现123456789101112131415161718192021222324252627282930313233class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; // 设置哨兵节点 ListNode dummy = new ListNode(0); // 哨兵节点后继为真正的头节点 dummy.next = head; // cur指针初始指向头节点 ListNode cur = head; // pre指针初始指向哨兵节点 ListNode pre = dummy; while (cur != null) &#123; // 找出相同节点：即将cur指针移动到最后一个相同节点的next节点 while (cur.next != null &amp;&amp; cur.val == cur.next.val) &#123; cur = cur.next; &#125; // 当前节点即使不与后继节点重复，cur也要后移一个节点 cur = cur.next; // 链表没有重复节点，pre指针向后移 if (pre.next.next == cur) &#123; pre = pre.next; &#125; else &#123; // 如果有，pre指向cur pre.next = cur; &#125; &#125; return dummy.next; &#125;&#125;","categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 83 —— 删除排序链表中的重复元素","slug":"Leetcode 83 —— 删除排序链表中的重复元素","date":"2021-04-17T13:22:36.000Z","updated":"2021-04-17T13:36:13.041Z","comments":true,"path":"2021/04/17/Leetcode 83 —— 删除排序链表中的重复元素/","link":"","permalink":"http://example.com/2021/04/17/Leetcode%2083%20%E2%80%94%E2%80%94%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","excerpt":"","text":"思路设置cur指针指向链表头节点，遍历链表判断当前节点是否和后继节点相等，相等则删除此后继节点，不相等则将当前节点后移。 边界处理： 注意，不需要设置虚拟头节点，cur初始时指向头节点即可；遍历实际上只需要走到倒数第二个节点即可，当cur走到倒数第二个节点的时候能够判断最后一个节点是否重复。判定倒数第二个节点的条件是当前节点不为空且其后继节点不为空。 Java实现123456789101112131415class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode cur = head; while (cur != null &amp;&amp; cur.next != null) &#123; if (cur.val == cur.next.val) &#123; cur.next = cur.next.next; &#125; else &#123; cur = cur.next; &#125; &#125; return head; &#125;&#125;","categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 83 —— 删除排序链表中的重复元素","slug":"Leetcode-83-——-删除排序链表中的重复元素","date":"2021-04-17T13:22:36.000Z","updated":"2021-04-17T13:23:36.774Z","comments":true,"path":"2021/04/17/Leetcode-83-——-删除排序链表中的重复元素/","link":"","permalink":"http://example.com/2021/04/17/Leetcode-83-%E2%80%94%E2%80%94-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","excerpt":"","text":"思路设置cur指针指向链表头节点，遍历链表判断当前节点是否和后继节点相等，相等则删除此后继节点，不相等则将当前节点后移。 边界处理： 注意，不需要设置虚拟头节点，cur初始时指向头节点即可；遍历实际上只需要走到倒数第二个节点即可，当cur走到倒数第二个节点的时候能够判断最后一个节点是否重复。判定倒数第二个节点的条件是当前节点不为空且其后继节点不为空。 Java实现123456789101112131415class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode cur = head; while (cur != null &amp;&amp; cur.next != null) &#123; if (cur.val == cur.next.val) &#123; cur.next = cur.next.next; &#125; else &#123; cur = cur.next; &#125; &#125; return head; &#125;&#125;","categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]}],"categories":[],"tags":[{"name":"leetcode,算法","slug":"leetcode-算法","permalink":"http://example.com/tags/leetcode-%E7%AE%97%E6%B3%95/"}]}