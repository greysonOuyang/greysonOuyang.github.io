<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-01-17T06:58:11.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2021/01/17/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis学习笔记（一）入门案例"><a href="#Mybatis学习笔记（一）入门案例" class="headerlink" title="Mybatis学习笔记（一）入门案例"></a>Mybatis学习笔记（一）入门案例</h1><h2 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h2><ol><li><p>Mybatis的环境搭建</p><p> （数据库创建略过）</p><p> 第一步：创建Maven工程并导入坐标Pom.xml</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;groupId&gt;com.greyson&lt;/groupId&gt;     &lt;artifactId&gt;day91_mybatis&lt;/artifactId&gt;     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;     &lt;packaging&gt;jar&lt;/packaging&gt;     &lt;dependencies&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.mybatis&lt;/groupId&gt;             &lt;artifactId&gt;mybatis&lt;/artifactId&gt;             &lt;version&gt;3.4.1&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;mysql&lt;/groupId&gt;             &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;             &lt;version&gt;5.1.46&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;log4j&lt;/groupId&gt;             &lt;artifactId&gt;log4j&lt;/artifactId&gt;             &lt;version&gt;1.2.17&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;junit&lt;/groupId&gt;             &lt;artifactId&gt;junit&lt;/artifactId&gt;             &lt;version&gt;4.12&lt;/version&gt;         &lt;/dependency&gt;     &lt;/dependencies&gt; &lt;/project&gt;</code></pre><p> 第二步：创建实体类和Dao的接口（略）</p><p> 第三步： 创建Mybatis的主配置文件 SqlMapConfig.xml</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration         PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;         &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt;     &lt;environments default=&quot;mysql&quot;&gt;         &lt;!--configure mysql--&gt;         &lt;environment id=&quot;mysql&quot;&gt;             &lt;!--configure transaction type--&gt;             &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;             &lt;!--configure datasource--&gt;             &lt;dataSource type=&quot;POOLED&quot;&gt;                 &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                 &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;/&gt;                 &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                 &lt;property name=&quot;password&quot; value=&quot;HotteMYSQL&quot;/&gt;             &lt;/dataSource&gt;         &lt;/environment&gt;     &lt;/environments&gt;     &lt;!--Specified mapping location--&gt;     &lt;mappers&gt;         &lt;mapper resource=&quot;com/greyson/dao/IUserDao.xml&quot;/&gt;     &lt;/mappers&gt; &lt;/configuration&gt;</code></pre><p> 第四步：创建映射配置文件IUserDao.xml</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper         PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;         &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.greyson.dao.IUserDao&quot;&gt;     &lt;select id=&quot;findAll&quot; resultType=&quot;com.greyson.domain.User&quot;&gt;         select * from user     &lt;/select&gt; &lt;/mapper&gt;</code></pre></li><li><p>环境搭建的注意事项</p><ul><li><p>Mybatis中把持久层的操作接口名称和映射文件都叫做：Mapper，所以 IUserDao 和 IUserMapper 是一样的</p></li><li><p>Mybatis 的映射配置文件位置必须和 dao 接口的包结构一致</p></li><li><p>映射配置文件的 mapper 标签 namespace 属性的取值必须是 dao 接口的全限定类名</p></li><li><p>映射配置文件的操作配置（select），id 属性的取值必须是 dao 接口的方法名</p><p>遵从以上规则，开发中则无须再写 dao 的实现类。</p></li></ul></li><li><p>编写测试类MyBatisTest</p><pre><code> public class MybatisTest&#123;     /**      * Getting started case      * @param args      */     public static void main(String[] args) throws Exception &#123;         // 1. Read configuration file         InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);         // 2. Create SqlSessionFactory         SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();         SqlSessionFactory factory = builder.build(in);         // 3. Use factory generate SqlSession Object         SqlSession session = factory.openSession();         // 4. Use SqlSession generate proxy object of DAO interface         IUserDao userDao = session.getMapper(IUserDao.class);         // 5. Use proxy object execution         List&lt;User&gt; userList = userDao.findAll();         for (User user : userList) &#123;             System.out.println(user);         &#125;         // 6. Release resources         session.close();         in.close();     &#125; &#125;</code></pre></li><li><p>文件结构（补充）</p><p> <img src="./mybatis_png/1.png"></p></li><li><p>测试结果</p><p> <img src="./mybatis_png/1.png"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mybatis学习笔记（一）入门案例&quot;&gt;&lt;a href=&quot;#Mybatis学习笔记（一）入门案例&quot; class=&quot;headerlink&quot; title=&quot;Mybatis学习笔记（一）入门案例&quot;&gt;&lt;/a&gt;Mybatis学习笔记（一）入门案例&lt;/h1&gt;&lt;h2 id=&quot;一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Readme/"/>
    <id>http://example.com/2021/01/17/Readme/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring学习笔记"><a href="#Spring学习笔记" class="headerlink" title="Spring学习笔记"></a>Spring学习笔记</h1><p><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B.md">Spring学习笔记（一）入门案例</a></p><p><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Bean%E7%9A%84%E8%A3%85%E9%85%8D%E4%B8%8E%E7%AE%A1%E7%90%86.md">Spring学习笔记（二）Bean的装配与管理</a></p><p><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.md">Spring学习笔记（三）依赖注入</a></p><p><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9F%BA%E4%BA%8Exml%E7%9A%84IOC%E6%A1%88%E4%BE%8B.md">Spring学习笔记（四）基于xml的IOC案例</a></p><p><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IOC.md">Spring学习笔记（五）基于注解的IOC</a></p><p><a href="./Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89Spring%E6%95%B4%E5%90%88Junit.md">Spring学习笔记（六）Spring整合Junit</a></p><p><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90.md">Spring学习笔记（七）动态代理分析</a></p><p><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89AOP%E6%A6%82%E5%BF%B5.md">Spring学习笔记（八）AOP概念</a></p><p><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89AOP%E5%AE%9E%E4%BE%8B.md">Spring学习笔记（九）AOP实例</a></p><p><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89JdbcTemplate.md">Spring学习笔记（十）JdbcTemplate</a></p><p><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86.md">Spring学习笔记（十一）事务管理</a></p><h1 id="Mybatis学习笔记"><a href="#Mybatis学习笔记" class="headerlink" title="Mybatis学习笔记"></a>Mybatis学习笔记</h1><p><a href="Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B.md">Mybatis学习笔记（一）入门案例</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring学习笔记&quot;&gt;&lt;a href=&quot;#Spring学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记&quot;&gt;&lt;/a&gt;Spring学习笔记&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;Spring%E5%AD%A6%E4%B9%A0%E7%A</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring学习笔记（一）入门案例"><a href="#Spring学习笔记（一）入门案例" class="headerlink" title="Spring学习笔记（一）入门案例"></a>Spring学习笔记（一）入门案例</h1><h2 id="一、Spring入门案例"><a href="#一、Spring入门案例" class="headerlink" title="一、Spring入门案例"></a>一、Spring入门案例</h2><h3 id="1、实例"><a href="#1、实例" class="headerlink" title="1、实例"></a>1、实例</h3><ol><li>通过 Idea 创建 maven 项目</li><li>配置 Spring 配置文件 ApplicationContext.xml</li><li>编写接口及实现类</li></ol><ul><li>IaccountDao</li></ul><pre><code>    /**     * 账户的持久层接口     */    public interface IAccountDao &#123;        /**         * 模拟保存账户         */        void saveAccount();    &#125;</code></pre><ul><li>IaccountService</li></ul><pre><code>    /**     * 账户业务层的接口     */    public interface IAccountService &#123;        /**         * 模拟保存账户         */        void saveAccount();    &#125;</code></pre><ul><li>AccountDaoImpl</li></ul><pre><code>    /**     * 账户的持久层实现类     */    public class AccountDaoImpl implements IAccountDao &#123;        public  void saveAccount()&#123;            System.out.println(&quot;保存了账户&quot;);        &#125;    &#125;</code></pre><ul><li>AccountServiceImpl</li></ul><pre><code>    /**     * 账户的业务层实现类     */    public class AccountServiceImpl implements IAccountService &#123;        private IAccountDao accountDao = new AccountDaoImpl();        public void  saveAccount()&#123;            accountDao.saveAccount();        &#125;    &#125;</code></pre><ol start="4"><li><p>编写测试类 Client</p><p>  /**</p><ul><li>模拟一个表现层，用于调用业务层</li><li>/<br>public class Client {<br>  /**<br>   *<br>   *获取IOC的核心容器，并根据id获取对象<ul><li>@param args</li><li>/<br>public static void main(String[] args) {<br>  ApplicationContext ac = new ClassPathXmlApplicationContext(“beans.xml”);<br>  // 两种不同的方式获取Bean对象<br>  IAccountService as = (IAccountService) ac.getBean(“accountService”);<br>  IAccountDao adao = ac.getBean(“accountDao”,IAccountDao.class);<br>  System.out.println(as);<br>  System.out.println(adao);<pre><code>      //        as.saveAccount();</code></pre>}<br>}</li></ul></li></ul></li></ol><h3 id="2、知识点"><a href="#2、知识点" class="headerlink" title="2、知识点"></a>2、知识点</h3><ol><li><p>ApplicationContext的三个常用实现类：</p><ul><li><p>ClassPathXmlApplicationContext： 它可以加载路径下的配置文件，要求配置文件必须在路径下，否则加载不了</p><pre><code>  ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bea  ns.xml&quot;);</code></pre></li><li><p>FileSyetemXmlApplicationContext：它可以加载磁盘下任意路径下的配置文件（必须有访问权限）</p><p>  加载方式如下：</p><pre><code>  ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;C:\\user\\greyson\\...&quot;)</code></pre></li><li><p>AnnotationConfigApplicationContext：它是用于读取注解创建容器的</p></li></ul></li><li><p>核心容器的两个接口引发出来的问题</p><ul><li>ApplicationContext：它在创建核心容器时，创建对象采取的策略是采用立即加载的方式，也就是说，只要一读取完配置文件就马上创建配置文件中配置的对象<ul><li>单例对象适用</li><li>开发中常采用此接口</li></ul></li><li>BeanFactory: 它在构建核心容器时，创建对象的策略是采用延迟加载的方式，什么时候获取 id 对象了，什么时候就创建对象。<ul><li>多例对象适用</li></ul></li></ul></li></ol><h1 id="Spring学习笔记（二）Bean的装配与管理"><a href="#Spring学习笔记（二）Bean的装配与管理" class="headerlink" title="Spring学习笔记（二）Bean的装配与管理"></a><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Bean%E7%9A%84%E8%A3%85%E9%85%8D%E4%B8%8E%E7%AE%A1%E7%90%86.md">Spring学习笔记（二）Bean的装配与管理</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring学习笔记（一）入门案例&quot;&gt;&lt;a href=&quot;#Spring学习笔记（一）入门案例&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记（一）入门案例&quot;&gt;&lt;/a&gt;Spring学习笔记（一）入门案例&lt;/h1&gt;&lt;h2 id=&quot;一、Spr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring学习笔记（三）依赖注入"><a href="#Spring学习笔记（三）依赖注入" class="headerlink" title="Spring学习笔记（三）依赖注入"></a>Spring学习笔记（三）依赖注入</h1><h2 id="三、依赖注入（Dependency-Injection）"><a href="#三、依赖注入（Dependency-Injection）" class="headerlink" title="三、依赖注入（Dependency Injection）"></a>三、依赖注入（Dependency Injection）</h2><h3 id="（一）、概述"><a href="#（一）、概述" class="headerlink" title="（一）、概述"></a>（一）、概述</h3><ol><li><p>能注入的数据：</p><ul><li>基本类型和 String</li><li>其他 bean 类型（在配置文件中或者注解中配置过的bean）</li><li>复杂类型/集合类型</li></ul></li><li><p>IOC的作用：减低程序间的耦合（即依赖关系）</p><p> 在当前类需要用到其他类的对象，由 Spring 为我们提供，而我们在配置文件中说明依赖关系的维护，这种方式就称为依赖注入。</p></li></ol><h3 id="（二）、注入方式"><a href="#（二）、注入方式" class="headerlink" title="（二）、注入方式"></a>（二）、注入方式</h3><ol><li><p>操作实例：</p><ul><li><p>接口如下：</p><pre><code>  public interface IAccountDao &#123;      void saveAccount();  &#125;  public interface IAccountService &#123;      /**       * 模拟保存账户       */      void saveAccount();  &#125;</code></pre></li><li><p>实现类：</p><pre><code>  @Service(&quot;accountService&quot;)  public class AccountServiceImpl implements IAccountService &#123;      @Autowired      @Qualifier(&quot;accountDao2&quot;)      private IAccountDao accountDao = null;</code></pre></li></ul></li></ol><pre><code>            public void  saveAccount() &#123;                accountDao.saveAccount();            &#125;        &#125;        @Repository(&quot;accountDao1&quot;)        public class AccountDaoImpl implements IAccountDao &#123;            public void  saveAccount() &#123;                System.out.println(&quot;对象创建了111&quot;);            &#125;        &#125;        @Repository(&quot;accountDao2&quot;)        public class IAccountDaoImpl2 implements IAccountDao&#123;            public void  saveAccount() &#123;                System.out.println(&quot;对象创建了222&quot;);            &#125;        &#125;</code></pre><ol start="2"><li><p>第三种：使用注解提供</p><ol><li><p>如何使用？</p><p> 第一步：在类或方法的前面加上注解关键字</p><p> 第二步：引入约束,注意此处约束多了xmlns:context…</p><p> 第三步：添加配置文件，告知 Spring 在创建容器时要扫描的包，配置所需的标签不是在 bean 约束中，而是一个名称为context 的名称孔家和约束中,完整配置如下：</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd         http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;     &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; &lt;/beans&gt;</code></pre><ol><li><p>有哪些注解？</p><ol><li><p>用于创建对象的</p><p> 作用：等同于 xml 配置文件中编写一个 <bean> 标签</p><ul><li><p>@Component</p><ul><li><p>形式：@Component(value=” “)/@Component(“ “)</p></li><li><p>作用：用于把当前类对象存入 Spring 容器中</p></li><li><p>属性：</p><p>  value : 用于指定 bean 的 id，当我们不写的时候，它的默认值是当前类名，且首字母改小写;当值只有一个的时候可以省略</p></li></ul><p>以下三个注解的作用与 @Component 完全一样，它们是 Spring 提供的更明确的划分，使三层对象更加清晰</p></li><li><p>@Controller  用于表现层</p></li><li><p>@Service       用于业务层</p></li><li><p>@Repository 用于持久层</p></li></ul></li><li><p>用于注入数据的</p><p> 作用：等同于在 <bean> 标签中写一个 <property> 标签</p><ul><li><p>@Autowired</p><ul><li>作用：自动按照类型注入，只要容器中有唯一的一个 bean 对象类型和要注入的变量类型匹配，  就可以注入成功如果IOC容器中没有任何 bean 的类型和要注入的变量类型匹配，则报错</li><li>出现位置：可以是变量上，也可以是方法上，</li><li>细节：在使用注解注入时，set 方法就不是必须的了</li></ul></li><li><p>@Qualifier</p><ul><li><p>作用：在按照类型注入的基础上再按照名称注入，它在给类成员注入时不能单独使用，但是在给方法参数注入          时可以。</p></li><li><p>属性：</p><p>  value : 用于指定注入的 bean 的  id</p></li></ul></li><li><p>@Resource</p><ul><li><p>作用：直接按照 bean 的 id 注入，可以直接使用</p></li><li><p>属性：</p><p>  name : 用于指定 bean 的 id</p></li><li><p>等同于@Autowired+@Qualifier</p></li></ul><p>以上三个注入都只能注入其他 bean 类型的数据，而基本类型和 String 类型的数据无法使用上述注解实现。另外，集合类型的注入只能通过 xml 配置文件实现</p></li><li><p>@Value</p><ul><li><p>作用：用于注入基本类型和 String 类型的数据</p></li><li><p>属性：</p><p>  value : 用于指定数据的值，它可以使用 Spring 中 Spel (即spring的el表达式)</p><p>  Spel 的写法：${表达式}</p></li></ul></li></ul></li><li><p>用于改变范围的</p><p>作用：等同于在 <bean> 标签中使用 scope 属性</p></li></ol><ul><li><p>@Scope</p><ul><li><p>作用：用于指定 bean 的作用范围</p></li><li><p>属性：</p><p>  value : 指定范围的取值，同 xml 中值，常用为 singleton ,  prototype</p></li></ul></li></ul><ol start="4"><li><p>和生命周期相关（了解）</p><p>作用：等同于在<bean>标签中使用 init-method 和 destroy-method</p></li></ol><ul><li><p>@PreDestory</p><p>  作用：用于指定销毁方法</p></li><li><p>@Postcontrust</p><p>  作用：用于指定初始化方法</p></li></ul></li></ol></li></ol><ul><li><p>测试类：</p><pre><code>  public static void main(String[] args) &#123;          //1.获取核心容器对象          ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);          //2.根据id获取Bean对象          IAccountService as  = (IAccountService)ac.getBean(&quot;accountService&quot;);          as.saveAccount();      &#125;  &#125;</code></pre></li></ul></li><li><p>第二种：使用 set 方法提供（更常用的方式）</p><p> 使用的标签：property</p><p> 出现的位置：bean 标签的内部</p><p> 标签的属性：</p><p> name : 用于指定注入时所使用的 set 方法</p><p> value : 用于提供基本类型和 String 类型的数据</p><p> ref : 用于指定其他的bean类型数据，它指的就是在 Spring 容器中出现过的bean对象</p><p> 优势：创建对象时没有明确的限制，可以直接使用默认构造函数</p><p> 弊端：如果有某个成员必须有值，是有可能 set 方法没有执行</p><ol><li><p>基本类型和 String 的注入方式</p><ul><li><p>业务层</p><pre><code>  public class AccountServiceImpl implements IAccountService &#123;      // 如果时经常变化的数据不适用于依赖注入，此处仅为演示      private String name;      private Integer age;      private Date birthday;      public void setName(String name) &#123;          this.name = name;      &#125;      public void setAge(Integer age) &#123;          this.age = age;      &#125;      public void setBirthday(Date birthday) &#123;          this.birthday = birthday;      &#125;      public void  saveAccount() &#123;          System.out.println(&quot;service中的saveaccount()执行了&quot; + name + &quot;,&quot; + age + &quot;,&quot; +birthday);      &#125;  &#125;</code></pre></li><li><p>配置bean.xml</p><pre><code>  &lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;          &lt;property name=&quot;name&quot; value =&quot;taylor&quot;&gt;&lt;/property&gt;          &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;          &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;      &lt;bean id = &quot;now&quot; class = &quot;java.util.Date&quot;&gt;&lt;/bean&gt;</code></pre><p>  测试类同上</p></li></ul></li><li><p>复杂集合类型的注入方式</p><ul><li><p>用于给 List 结构集合注入的标签</p><ul><li>list</li><li>array</li><li>set</li></ul></li><li><p>用于给map结构集合注入的标签</p><ul><li>map</li><li>properties</li></ul><p>结构相同，标签可以互换，因此开发中只要记住两组标签即可</p><p>编写实例：</p><p>  public class AccountServiceImpl implements IAccountService {</p><pre><code>  private String[] myStrs;  private List&lt;String&gt; myList;  private Set&lt;String&gt; mySet;  private Map&lt;String, String&gt; myMap;  private Properties myProps;  public void setMyStrs(String[] myStrs) &#123;      this.myStrs = myStrs;  &#125;  public void setMyList(List&lt;String&gt; myList) &#123;      this.myList = myList;  &#125;  public void setMySet(Set&lt;String&gt; mySet) &#123;      this.mySet = mySet;  &#125;  public void setMyMap(Map&lt;String, String&gt; myMap) &#123;      this.myMap = myMap;  &#125;  public void setMyProps(Properties myProps) &#123;      this.myProps = myProps;  &#125;  public void  saveAccount() &#123;      System.out.println(Arrays.toString(myStrs));      System.out.println(myList);      System.out.println(myMap);      System.out.println(mySet);      System.out.println(myProps);  &#125;</code></pre><p>  }</p><p>配置如下：</p>  <bean id = "accountService" class = "com.itheima.service.impl.AccountServiceImpl">          <!--以下三个标签是等价的，set未列出-->          <property name="myList">              <list>                  <value>aaa</value>                  <value>bbb</value>              </list>          </property><pre><code>      &lt;property name=&quot;myStrs&quot;&gt;          &lt;array&gt;              &lt;value&gt;aaa&lt;/value&gt;              &lt;value&gt;bbbb&lt;/value&gt;          &lt;/array&gt;      &lt;/property&gt;      &lt;property name=&quot;mySet&quot;&gt;          &lt;array&gt;              &lt;value&gt;aaa&lt;/value&gt;              &lt;value&gt;bbbb&lt;/value&gt;          &lt;/array&gt;      &lt;/property&gt;      &lt;!--以下两种方式等价--&gt;      &lt;property name=&quot;myMap&quot;&gt;          &lt;map&gt;              &lt;!--以下两种配置方式都可以--&gt;              &lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt;              &lt;entry key=&quot;testA&quot;&gt;                  &lt;value&gt;bbb&lt;/value&gt;              &lt;/entry&gt;          &lt;/map&gt;      &lt;/property&gt;      &lt;property name=&quot;myProps&quot;&gt;          &lt;props&gt;              &lt;prop key=&quot;testB&quot;&gt;bbb&lt;/prop&gt;          &lt;/props&gt;      &lt;/property&gt;  &lt;/bean&gt;</code></pre></li></ul></li></ol></li><li><p>第一种：使用构造函数提供</p><p> 使用的标签：constructor-arg</p><p> 标签所在位置：bean 标签的内部</p><p> 标签中的属性：</p><ul><li><p>type : 用于指定要注入的数据类型，该类型也是构造函数中某个或某些参数的类型</p></li><li><p>index : 用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引的位置时从0开始</p></li><li><p>name(常用) : 用于指定给构造函数中指定名称的参数赋值</p></li><li><p>value : 用于提供基本类型和String类型的数据</p></li><li><p>ref : 用于指定其他的bean类型数据。它指的就是在spring的IOC核心容器出现过的bean对象</p><p>特点：在获取 bean 对象时，注入数据是必须的操作，否则无法操作成功</p><p>弊端：改变了 bean 对象的实例化方式，使我们在用不到这些数据的情况下也必须提供带参构造函数，因此开发中较少使用此方法，除非避无可避</p><p>例：</p><p>  public class AccountServiceImpl implements IAccountService {</p><pre><code>  // 如果时经常变化的数据不适用于依赖注入，此处仅为演示  private String name;  private Integer age;  private Date birthday;  public AccountServiceImpl(String name, Integer age, Date birthday)&#123;      this.name = name;      this.age = age;      this.birthday = birthday;  &#125;  public void  saveAccount() &#123;      System.out.println(&quot;service中的saveaccount()执行了&quot;);  &#125;</code></pre><p>  }</p><p>测试类：</p><p>  public static void main(String[] args) {</p><pre><code>      //1.获取核心容器对象      ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);      //2.根据id获取Bean对象      IAccountService as  = (IAccountService)ac.getBean(&quot;accountService&quot;);      as.saveAccount();  &#125;</code></pre><p>配置如下：</p>  <bean id = "accountService" class = "com.itheima.service.impl.AccountServiceImpl">          <constructor-arg name = "name" value="taylor"></constructor-arg>          <constructor-arg name = "age" value = "23"></constructor-arg>          <constructor-arg name = "birthday" ref = "now"></constructor-arg>      </bean><pre><code>  &lt;bean id = &quot;now&quot; class = &quot;java.util.Date&quot;&gt;&lt;/bean&gt;</code></pre></li></ul></li></ol><p>如上，AccountDaoImpl1 和 AccountDaoImpl2 实现接口 IAccountDao ，两个类中分别实现了不同的 saveAccount() 方法，AccountServiceImpl 实现接口 IAccountService ，其中调用了 IAccountDao 接口。AccountServiceImpl 通过注解关键字 Autowired 去 Spring 容器中寻找 accountDao ， 再根据 Qualifier 配置的 value 找到两个 dao 的实现类中与之相匹配的 Repository 的值。</p><h1 id="Spring学习笔记（四）基于xml的IOC案例"><a href="#Spring学习笔记（四）基于xml的IOC案例" class="headerlink" title="Spring学习笔记（四）基于xml的IOC案例"></a><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9F%BA%E4%BA%8Exml%E7%9A%84IOC%E6%A1%88%E4%BE%8B.md">Spring学习笔记（四）基于xml的IOC案例</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring学习笔记（三）依赖注入&quot;&gt;&lt;a href=&quot;#Spring学习笔记（三）依赖注入&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记（三）依赖注入&quot;&gt;&lt;/a&gt;Spring学习笔记（三）依赖注入&lt;/h1&gt;&lt;h2 id=&quot;三、依赖注</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring学习笔记（七）动态代理分析"><a href="#Spring学习笔记（七）动态代理分析" class="headerlink" title="Spring学习笔记（七）动态代理分析"></a>Spring学习笔记（七）动态代理分析</h1><h2 id="七、动态代理分析"><a href="#七、动态代理分析" class="headerlink" title="七、动态代理分析"></a>七、动态代理分析</h2><h3 id="1、什么是代理？"><a href="#1、什么是代理？" class="headerlink" title="1、什么是代理？"></a>1、什么是代理？</h3><p>简单理解，本来厂商可以自产自销，但是由于各种开销，最后厂商选择只生产产品，销售则交由各级经销商完成。</p><p><img src="-d7c45db4-1f69-4b5c-b5f5-a9624176e6f8.png"></p><ul><li><p>特点：字节码随用随创建，随用随加载</p></li><li><p>作用：不修改源码的基础上对方法增强</p></li><li><p>分类：</p><p>  基于接口的动态代理</p><p>  基于子类的动态代理</p></li></ul><h3 id="2、基于接口的动态代理"><a href="#2、基于接口的动态代理" class="headerlink" title="2、基于接口的动态代理"></a>2、基于接口的动态代理</h3><ol><li><p>基于接口的动态代理：</p><p> 涉及的类：Proxy</p><p> 提供者：JDK官方</p></li><li><p>如何创建代理对象：</p><p> 使用Proxy类中的newProxyInstance方法</p></li><li><p>创建代理对象的要求：</p><p> 被代理类最少实现的一个接口，如果没有则不能使用</p></li><li><p>newProxyInstance方法的参数：</p><p> ClassLoader : 用于加载代理对象字节码，和被代理对象使用相同的类加载器，固定写法</p><p> Class [ ] : 用于让代理对象和被代理对象有相同的方法，固定写法</p><p> InvocationHandler : 用于提供增强的代码</p><p> 它是让我们写如何代理。我们一般是写一个该接口的实现类，通常是匿名内部类，但不是必须的。此接口的实现类都是谁用谁写。</p></li></ol><ul><li><p>生产厂家接口IProducer</p><pre><code>  /**   * 对生产厂家要求的接口   */  public interface IProducer &#123;      /**       * 销售       * @param money       */      public void saleProduct(float money);      /**       * 售后       * @param money       */      public void afterService(float money);  &#125;</code></pre></li><li><p>生产者</p><pre><code>  /**   * 一个生产者   */  public class Producer implements IProducer &#123;      /**       * 销售       * @param money       */      public void saleProduct(float money) &#123;          System.out.println(&quot;销售产品，并拿到钱：&quot; + money);      &#125;      /**       * 售后       * @param money       */      public void afterService(float money) &#123;          System.out.println(&quot;提供售后服务，并拿到钱：&quot; + money);      &#125;  &#125;</code></pre></li><li><p>消费者</p><pre><code>  /**   * 模拟一个消费者   */  public class Client &#123;      public static void main(String[] args) &#123;          final Producer producer = new Producer();          IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),                  producer.getClass().getInterfaces(), new InvocationHandler() &#123;                      /**                       * 作用：执行被代理对象的任何接口方法都会经过该方法                       * 方法参数的含义：                       * @param proxy         代理对象的含义                       * @param method        当前执行的方法                       * @param args          当前执行方法的参数                       * @return              和被代理对象方法有相同的返回值                       * @throws Throwable                       */                      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                          // 提供增强的代码                          Object returnValue = null;                          // 1.获取方法执行的参数                          Float money = (Float)args[0];                          // 2.判断当前方法是不是销售                          if (&quot;saleProduct&quot;.equals(method.getName())) &#123;                              returnValue = method.invoke(producer,money * 0.8f);                          &#125;                          return returnValue;                      &#125;                  &#125;);      &#125;  &#125;</code></pre></li></ul><h3 id="3、基于子类的动态代理"><a href="#3、基于子类的动态代理" class="headerlink" title="3、基于子类的动态代理"></a>3、基于子类的动态代理</h3><ol><li><p>基于子类的动态代理：</p><p> 涉及的类：Enhancer</p><p> 提供者：第三方 cglib 库</p></li><li><p>如何创建代理对象：</p><p> 使用 Enhancer 类中的 create 方法</p></li><li><p>创建代理对象的要求：</p><p> 被代理类不能是最终类</p></li><li><p>create 方法的参数：</p><p> Class : 它是用于被指定代理对象的字节码</p><p> callback : 用于提供增强的代码</p><p> 它是让我们写如何代理。我们一般是写一个该接口的实现类，通常是匿名内部类，但不是必须的。此接口的实现类都是谁用谁写。我们一般写的都是该接口的子实现类：MethodInterCeptor</p></li></ol><ul><li><p>生产者</p><pre><code>  public class Producer &#123;      /**       * 销售       * @param money       */      public void saleProduct(float money) &#123;          System.out.println(&quot;销售产品，并拿到钱：&quot; + money);      &#125;      /**       * 售后       * @param money       */      public void afterService(float money) &#123;          System.out.println(&quot;提供售后服务，并拿到钱：&quot; + money);      &#125;  &#125;</code></pre></li><li><p>消费者</p><pre><code>  /**   * 模拟一个消费者   */  public class Client &#123;      public static void main(String[] args) &#123;          final Producer producer = new Producer();          Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() &#123;              public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;                  // 提供增强的代码                  Object returnValue = null;                  // 1.获取方法执行的参数                  Float money = (Float)args[0];                  // 2.判断当前方法是不是销售                  if (&quot;saleProduct&quot;.equals(method.getName())) &#123;                      returnValue = method.invoke(producer,money * 0.8f);                  &#125;                  return returnValue;              &#125;          &#125;);          cglibProducer.saleProduct(12000f);      &#125;  &#125;</code></pre></li></ul><h1 id="Spring学习笔记（八）AOP概念"><a href="#Spring学习笔记（八）AOP概念" class="headerlink" title="Spring学习笔记（八）AOP概念"></a><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89AOP%E6%A6%82%E5%BF%B5.md">Spring学习笔记（八）AOP概念</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring学习笔记（七）动态代理分析&quot;&gt;&lt;a href=&quot;#Spring学习笔记（七）动态代理分析&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记（七）动态代理分析&quot;&gt;&lt;/a&gt;Spring学习笔记（七）动态代理分析&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89AOP%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89AOP%E6%A6%82%E5%BF%B5/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring学习笔记（八）AOP概念"><a href="#Spring学习笔记（八）AOP概念" class="headerlink" title="Spring学习笔记（八）AOP概念"></a>Spring学习笔记（八）AOP概念</h1><h2 id="八、AOP-面向切面编程-的概念"><a href="#八、AOP-面向切面编程-的概念" class="headerlink" title="八、AOP ( 面向切面编程 ) 的概念"></a>八、AOP ( 面向切面编程 ) 的概念</h2><h3 id="1、什么是AOP"><a href="#1、什么是AOP" class="headerlink" title="1、什么是AOP?"></a>1、什么是AOP?</h3><p>在单体架构下的软件开发中，一个大型项目通常是依照功能拆分成各个模块。但是如日志、安全和事务管理此类重要且繁琐的开发却没有必要参与到各个模块中，将这些功能与业务逻辑相关的模块分离就是面向切面编程所要解决的问题</p><p><strong>AOP采取的是横向抽取机制，取代了传统纵向继承体系重复性代码。</strong></p><h3 id="2、那么何为软件的横向和纵向？"><a href="#2、那么何为软件的横向和纵向？" class="headerlink" title="2、那么何为软件的横向和纵向？"></a>2、那么何为软件的横向和纵向？</h3><p>从纵向结构来看就是我们软件的各个模块，它所负责的是软件的核心业务（如购商品购买、添加购物车等）；从横向来看的话，软件的各个模块之间又有所关联，其中会包含一些公共模块（例如日志、权限等）；这些公共模块可以存在于各个核心业务中，而AOP的处理将两者分离，使开发人员可以专注于核心业务的开发，提高了开发效率。</p><h3 id="3、AOP-的作用及优势"><a href="#3、AOP-的作用及优势" class="headerlink" title="3、AOP 的作用及优势"></a>3、AOP 的作用及优势</h3><p>作用： 在程序运行期间，不修改源码对已有方法进行增强。</p><p>优势： 减少重复代码 提高开发效率 维护方便</p><h3 id="4、AOP底层原理"><a href="#4、AOP底层原理" class="headerlink" title="4、AOP底层原理"></a>4、AOP底层原理</h3><p>使用动态代理实现<br>（1）基于JDK的代理</p><pre><code>适用于有接口情况，使用动态代理创建接口实现类代理对象</code></pre><p>（2）基于CGLIB动态代理</p><pre><code>适用于没有接口情况，使用动态代理创建类的子类代理对象</code></pre><h1 id="Spring学习笔记（九）AOP实例"><a href="#Spring学习笔记（九）AOP实例" class="headerlink" title="Spring学习笔记（九）AOP实例"></a><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89AOP%E5%AE%9E%E4%BE%8B.md">Spring学习笔记（九）AOP实例</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring学习笔记（八）AOP概念&quot;&gt;&lt;a href=&quot;#Spring学习笔记（八）AOP概念&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记（八）AOP概念&quot;&gt;&lt;/a&gt;Spring学习笔记（八）AOP概念&lt;/h1&gt;&lt;h2 id=&quot;八</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89AOP%E5%AE%9E%E4%BE%8B/"/>
    <id>http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89AOP%E5%AE%9E%E4%BE%8B/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring学习笔记（九）AOP实例"><a href="#Spring学习笔记（九）AOP实例" class="headerlink" title="Spring学习笔记（九）AOP实例"></a>Spring学习笔记（九）AOP实例</h1><h2 id="九、Spring中的AOP"><a href="#九、Spring中的AOP" class="headerlink" title="九、Spring中的AOP"></a>九、Spring中的AOP</h2><h3 id="1、AOP术语"><a href="#1、AOP术语" class="headerlink" title="1、AOP术语"></a>1、AOP术语</h3><ul><li>Advice (通知/增强): 所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。 通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。</li><li>Joinpoint (连接点): 所谓连接点是指那些被拦截到的点。在 Spring 中,这些点指的是方法,因为 Spring 只支持方法类型的 连接点。</li><li>Pointcut (切入点): 所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。</li><li>Introduction (引介): 引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方 法或 Field。 Target(目标对象): 代理的目标对象。</li><li>Weaving (织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 Spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。</li><li>Proxy（代理）: 一个类被 AOP 织入增强后，就产生一个结果代理类。 Aspec t(切面): 是切入点和通知（引介）的结合。</li></ul><h3 id="2-、Spring中基于-xml-的-AOP-配置步骤"><a href="#2-、Spring中基于-xml-的-AOP-配置步骤" class="headerlink" title="2 、Spring中基于 xml 的 AOP 配置步骤"></a>2 、Spring中基于 xml 的 AOP 配置步骤</h3><ol><li>把通知 Bean 也交给 Spring 来管理</li><li>使用 aop : config 标签来表明开始 AOP 的设置</li><li>使用 aop : aspect 标签配置切面<ul><li>id 属性：是给切面提供一个唯一标识</li><li>ref 属性：是指定通知类 Bean 的 id</li></ul></li><li>在 aop : aspect 标签的内部使用对应标签来配置通知的类型<ol><li>aop : before 标识前置通知<ul><li>method 属性：用于指定类中哪个放啊是前置通知</li><li>pointcut 属性：用于指定切入点表达式，该切入点表达式指的是对业务层中哪些方法增强</li></ul></li><li>切入点表达式的写法：<ul><li>关键字：execution ( 表达式 )</li><li>表达式：<ul><li>标准写法：访问修饰符 + 返回值 + 包名.类名.方法名（参数列表）</li><li>举例：public void com.greyson.service.impl.IAccountServiceImpl.saveAccount ( )</li></ul></li><li>全通配写法：<code>* * ..*.*(..)</code><ul><li>访问修饰符可以省略</li><li>返回值可以使用通配符，表示任意返回值</li><li>包名可以使用通配符，表示任意包，但是有几级包就需要写几个 <code>*.</code></li><li>包名可以使用  <code>..</code> 表示当前包和子包</li><li>类名和方法名都可以使用  <code>*</code> 来实现通配</li><li>参数列表：<ul><li>可以直接使写数据类型：<ul><li>基本类型直接写名称（如 int ）</li><li>引用类型写包名.类名的方式 （如 java.lang.String ）</li></ul></li><li>可以使用通配符表四任意类型，但是必须有参数</li><li>可以使用 <code>..</code> 表示有无参数即可，有参数可以是任意类型</li></ul></li></ul></li><li>实际开发中切入点表达式的通常写法：<ul><li>切到业务层类实现下的所有方法：<code>* com.greyson.service.impl.*.*(..)</code></li></ul></li><li>配置切入点表达式（aop : pointcut）：<ul><li>id属性用于指定表达式的唯一标识，expression属性用于指定表达式内容</li><li>此标签写在 aop : aspect 标签内部只能当前切面使用，在其外部则所有切面可用</li></ul></li></ul></li><li>Spring常用通知类型<ul><li>前置通知（aop : before）：在切入点方法执行之前执行</li><li>后置通知（aop : after-returning）：在切入点方法正常执行之后执行，它和异常通知永远只能执行一个</li><li>异常通知（aop : after-throwing）：在切入点方法执行产生异常之后执行，它和后置通知永远只能执行一个</li><li>最终通知（aop : after）：无论切入点方法是否正常执行它都会在其后面执行</li></ul></li><li> 环绕通知</li></ol></li></ol><h3 id="3、实例"><a href="#3、实例" class="headerlink" title="3、实例"></a>3、实例</h3><ol><li><p>引入 Maven 工程</p><ul><li><p>Pom.xml</p><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;           xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;      &lt;groupId&gt;com.greyson&lt;/groupId&gt;      &lt;artifactId&gt;day03_SpringAOP&lt;/artifactId&gt;      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;      &lt;packaging&gt;jar&lt;/packaging&gt;      &lt;build&gt;          &lt;finalName&gt;webapp&lt;/finalName&gt;          &lt;plugins&gt;              &lt;plugin&gt;                  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                  &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                  &lt;version&gt;3.6.0&lt;/version&gt;                  &lt;configuration&gt;                      &lt;source&gt;1.8&lt;/source&gt;                      &lt;target&gt;1.8&lt;/target&gt;                  &lt;/configuration&gt;              &lt;/plugin&gt;          &lt;/plugins&gt;      &lt;/build&gt;      &lt;dependencies&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-context&lt;/artifactId&gt;              &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;          &lt;/dependency&gt;          &lt;!--解析切入点表达式--&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.aspectj&lt;/groupId&gt;              &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;              &lt;version&gt;1.9.1&lt;/version&gt;          &lt;/dependency&gt;      &lt;/dependencies&gt;</code></pre></li></ul></li></ol><pre><code>        &lt;/project&gt;</code></pre><ol start="2"><li><p>编写业务代码</p><ul><li><p>IAccountService</p><pre><code>  /**   * 账户的业务层接口   */  public interface IAccountService &#123;      /**       * 模拟保存账户       *       */      void saveAccount();      /**       * 模拟更新账户       * @param i       */      void updateAccount(int i);      /**       * 删除账户       * @return       */      int deleteAccount();  &#125;</code></pre></li><li><p>AccountServiceImpl</p><pre><code>  /**   * 账户的业务层实现类   */  public class AccountServiceImpl implements IAccountService &#123;      @Override      public void saveAccount() &#123;          System.out.println(&quot;执行了保存&quot;);      &#125;      @Override      public void updateAccount(int i) &#123;          System.out.println(&quot;执行了更新&quot; + i);      &#125;      @Override      public int deleteAccount() &#123;          System.out.println(&quot;执行了删除&quot;);          return 0;      &#125;  &#125;</code></pre></li><li><p>Logger</p><pre><code>  /**   * 用于记录日志的工具类，它里面提供了公共的代码   */  public class Logger &#123;      public void printLog() &#123;          System.out.println(&quot;lOGGER类中的printLog开始记录日志了。。。&quot;);      &#125;  &#125;</code></pre></li></ul></li><li><p>配置Spring</p><ul><li><p>bean.xml</p><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans          http://www.springframework.org/schema/beans/spring-beans.xsd          http://www.springframework.org/schema/aop          http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;          &lt;!-- 配置Spring的IOC,把Service对象配置进来--&gt;          &lt;bean id=&quot;accountService&quot; class=&quot;com.greyson.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;          &lt;!--配置Logger类--&gt;          &lt;bean id=&quot;logger&quot; class=&quot;com.greyson.utils.Logger&quot;&gt;&lt;/bean&gt;          &lt;!--配置AOP--&gt;          &lt;aop:config&gt;                  &lt;!--配置切面--&gt;                  &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;                          &lt;!--配置通知的类型，并且建立通知方法和切入点方法的关联--&gt;                          &lt;aop:before method=&quot;printLog&quot; pointcut=&quot;execution(* com.greyson.service.impl.*.*(..))&quot;&gt;&lt;/aop:before&gt;                  &lt;/aop:aspect&gt;          &lt;/aop:config&gt;  &lt;/beans&gt;</code></pre></li></ul></li><li><p>编写测试类</p><ul><li><p>TestAOP</p><pre><code>  /**   * 测试AOP的配置   */  public class TestAOP &#123;      public static void main(String[] args) &#123;          // 1. 获取容器          ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);          // 2. 获取对象          IAccountService accountService = (IAccountService)applicationContext.getBean(&quot;accountService&quot;);          // 3. 执行方法          accountService.saveAccount();          accountService.updateAccount(1);          accountService.deleteAccount();      &#125;  &#125;</code></pre></li></ul></li></ol><h1 id="Spring学习笔记（十）JdbcTemplate"><a href="#Spring学习笔记（十）JdbcTemplate" class="headerlink" title="Spring学习笔记（十）JdbcTemplate"></a><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89JdbcTemplate.md">Spring学习笔记（十）JdbcTemplate</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring学习笔记（九）AOP实例&quot;&gt;&lt;a href=&quot;#Spring学习笔记（九）AOP实例&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记（九）AOP实例&quot;&gt;&lt;/a&gt;Spring学习笔记（九）AOP实例&lt;/h1&gt;&lt;h2 id=&quot;九</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Bean%E7%9A%84%E8%A3%85%E9%85%8D%E4%B8%8E%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Bean%E7%9A%84%E8%A3%85%E9%85%8D%E4%B8%8E%E7%AE%A1%E7%90%86/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring学习笔记（二）Bean的装配与管理"><a href="#Spring学习笔记（二）Bean的装配与管理" class="headerlink" title="Spring学习笔记（二）Bean的装配与管理"></a>Spring学习笔记（二）Bean的装配与管理</h1><h2 id="二、Spring-中-Bean-的细节"><a href="#二、Spring-中-Bean-的细节" class="headerlink" title="二、Spring 中 Bean 的细节"></a>二、Spring 中 Bean 的细节</h2><h3 id="（一）、三种创建-bean-对象的方式"><a href="#（一）、三种创建-bean-对象的方式" class="headerlink" title="（一）、三种创建 bean 对象的方式"></a>（一）、三种创建 bean 对象的方式</h3><ol><li><p>使用默认构造函数创建</p><p> 在spring的配置文件中，使用 id 和 class 属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建 bean 对象，此时如果类中没有默认构造函数，则对象无法创建。</p><pre><code> &lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;</code></pre></li><li><p>使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入 Spring容器）,如下</p><pre><code> /**  *模拟一个工厂类，该类可能存在于jar包中，无法通过修改源码的方式来提供默认构造函数  *   */ public class InstanceFactory &#123;     public IAccountService getAccountService() &#123;         return new AccountServiceImpl();     &#125; &#125;</code></pre><p> 配置方式如下：</p><pre><code> &lt;bean id = &quot;instanceFactory&quot; class = &quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;     &lt;bean id = &quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</code></pre></li><li><p>使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器），如下：</p><pre><code> public class StaticFactory &#123;     public  static IAccountService getAccountService() &#123;         return new AccountServiceImpl();     &#125; &#125;</code></pre><p> 配置方式如下：</p><pre><code> &lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</code></pre></li></ol><h3 id="（二）、bean-的作用范围调整"><a href="#（二）、bean-的作用范围调整" class="headerlink" title="（二）、bean 的作用范围调整"></a>（二）、bean 的作用范围调整</h3><ol><li><p>bean 标签的 scope 属性</p><p> 作用：用于指定 bean 的作用范围</p><p> 取值：常用的就是单例和多例</p><ul><li><p>singletond : 单例的（default）</p></li><li><p>prototype : 多例的</p></li><li><p>request : 作用于 web 应用的请求范围</p></li><li><p>session : 作用于 web  应用的会话范围</p></li><li><p>global-session : 作用于集群的会话范围（全局会话范围），当不是集群范围时，它就是 session</p></li><li><p>gloabl-session 示意图：</p><p>  <img src="session-988affbd-bff9-48fc-bb1d-5e135fe32082.png"></p></li></ul></li><li><p>bean对象的声明周期</p><p> 单例对象：</p><ul><li><p>出生：当容器创建时发生</p></li><li><p>活着：只要容器还在对象就一直活着</p></li><li><p>死亡：容器销毁，对象消亡</p><p>总结：单例对象的声明周期和容器相同</p><p>多例对象：</p></li><li><p>出生：当我们使用对象时 Spring 框架为我们创建</p></li><li><p>活着：对象只要是在使用过程中就活着</p></li><li><p>死亡：当对象长时间不用，且没有别的对象引用时，由 Java 的GC回收</p></li></ul></li></ol><h1 id="Spring学习笔记（三）依赖注入"><a href="#Spring学习笔记（三）依赖注入" class="headerlink" title="Spring学习笔记（三）依赖注入"></a><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.md">Spring学习笔记（三）依赖注入</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring学习笔记（二）Bean的装配与管理&quot;&gt;&lt;a href=&quot;#Spring学习笔记（二）Bean的装配与管理&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记（二）Bean的装配与管理&quot;&gt;&lt;/a&gt;Spring学习笔记（二）Bean</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IOC/"/>
    <id>http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IOC/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring学习笔记（五）基于注解的IOC"><a href="#Spring学习笔记（五）基于注解的IOC" class="headerlink" title="Spring学习笔记（五）基于注解的IOC"></a>Spring学习笔记（五）基于注解的IOC</h1><h2 id="五、基于注解的IOC实例"><a href="#五、基于注解的IOC实例" class="headerlink" title="五、基于注解的IOC实例"></a>五、基于注解的IOC实例</h2><p>基于xml实例，代码重复太多，就不贴出来了，主要是对于注解的应用，建议也手动敲一遍代码，对记忆和理解的加深有帮助。</p><ol><li><p>Spring 中的新注解：</p><ul><li><p>@Configuration</p><ul><li>作用：指定当前类是一个配置类</li><li>细节：当配置类作为 AnnotationConfigurationApplicationContext 对象创建的参数时，该注解可以不写</li></ul></li><li><p>@ComponentScan</p><ul><li><p>作用：用于通过注解指定 Spring 在创建容器时要扫描的包</p></li><li><p>属性：</p><p>  value : 它和 basepackages 的作用是一样的，都是用于指定创建容器时要扫描的包</p><p>  使用此注解就等同于在 xml 中配置了：</p><p>  &lt;context:component-scan base-package=”com.greyson”&gt;</context:component-scan></p></li></ul></li><li><p>@Bean</p><ul><li><p>作用：用于把当前方法的返回值作为 bean 对象放入 Spring 的IOC容器中</p></li><li><p>属性：</p><p>  name : 用于指定 bean 的 id，当不写时，默认值为当前方法的名称</p></li><li><p>细节：</p><p>  当我们使用注解配置方法时，如果方法有参数，Spring 框架会去容器中查找有没有可用的 bean 对象，</p><p>  查找的方式和 Autowired 注解的作用是一样的</p></li></ul></li><li><p>@I<em>mport</em></p><ul><li><p>作用：用于导入其他的配置类</p></li><li><p>属性：</p><p>  value : 用于指定其他配置类的字节码</p><p>  当我们使用 Import 的注解之后，有 Import 注解的类就是父配置类，而导入的都是子配置类</p></li></ul></li><li><p>@Properties</p><ul><li><p>作用：用于指定 properties 文件的位置</p></li><li><p>属性：</p><p>  value : 指定文件的名称和路径</p><p>  关键字：classpath , 表示类路径下</p></li></ul></li></ul></li></ol><h1 id="Spring学习笔记（六）Spring整合Junit"><a href="#Spring学习笔记（六）Spring整合Junit" class="headerlink" title="Spring学习笔记（六）Spring整合Junit"></a><a href="./Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89Spring%E6%95%B4%E5%90%88Junit.md">Spring学习笔记（六）Spring整合Junit</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring学习笔记（五）基于注解的IOC&quot;&gt;&lt;a href=&quot;#Spring学习笔记（五）基于注解的IOC&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记（五）基于注解的IOC&quot;&gt;&lt;/a&gt;Spring学习笔记（五）基于注解的IOC&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89Spring%E6%95%B4%E5%90%88Junit/"/>
    <id>http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89Spring%E6%95%B4%E5%90%88Junit/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring学习笔记（六）Spring整合Junit"><a href="#Spring学习笔记（六）Spring整合Junit" class="headerlink" title="Spring学习笔记（六）Spring整合Junit"></a>Spring学习笔记（六）Spring整合Junit</h1><h2 id="六、Spring-整合-Junit（后续补充）"><a href="#六、Spring-整合-Junit（后续补充）" class="headerlink" title="六、Spring 整合 Junit（后续补充）"></a>六、Spring 整合 Junit（后续补充）</h2><h3 id="1、Spring-整合-Junit-的配置过程："><a href="#1、Spring-整合-Junit-的配置过程：" class="headerlink" title="1、Spring 整合 Junit 的配置过程："></a>1、Spring 整合 Junit 的配置过程：</h3><ol><li><p>导入 Spring 整合 Junit 的 jar ( 坐标 )</p></li><li><p>使用 Junit 提供的一个注解把原有的 main 方法替换了，替换成 Spring 提供的</p><p> @Runwith</p></li><li><p>告知 Spring 的运行器， Spring 和 ioc 创建是基于 xml 还是注解的，并且说明位置，用到的注解如下</p><p> @ContextConfiguration</p><p> Locations : 指定 xml 文件的位置，加上 classpath 关键字，表示在类路径下</p><p> classes : 指定注解类所在地位置</p></li><li><p>使用@Autowired 给测试类中的变量注入数据</p></li></ol><h1 id="Spring学习笔记（七）动态代理分析"><a href="#Spring学习笔记（七）动态代理分析" class="headerlink" title="Spring学习笔记（七）动态代理分析"></a><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90.md">Spring学习笔记（七）动态代理分析</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring学习笔记（六）Spring整合Junit&quot;&gt;&lt;a href=&quot;#Spring学习笔记（六）Spring整合Junit&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记（六）Spring整合Junit&quot;&gt;&lt;/a&gt;Spring学习</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring学习笔记（十一）事务管理"><a href="#Spring学习笔记（十一）事务管理" class="headerlink" title="Spring学习笔记（十一）事务管理"></a>Spring学习笔记（十一）事务管理</h1><h2 id="十一、Spring的事务管理"><a href="#十一、Spring的事务管理" class="headerlink" title="十一、Spring的事务管理"></a>十一、Spring的事务管理</h2><h3 id="（一）、声明式事务管理"><a href="#（一）、声明式事务管理" class="headerlink" title="（一）、声明式事务管理"></a>（一）、声明式事务管理</h3><ol><li><p>Spring中基于 xml 的声明式事务控制配置步骤</p><p> ( 1 ) 配置事务管理器</p><p> ( 2 ) 配置事务的通知</p><ul><li>1 ) 导入事务的约束</li><li>2 ) 使用tx:advice标签配置事务通知<ul><li>属性：<ul><li>id：给事务通知起一个唯一标识</li><li>transaction-manager：给事务通知提供一个事务管理器引用</li></ul></li></ul></li><li>3 ) 配置AOP中的通用切入点表达式</li><li>4 ) 建立十五通知和切入点表达式的对应关系</li><li>5 ) 配置事务的属性（在事务的通知 tx : advice标签的内部）<ul><li>isolation：用于指定书屋的隔离级别，默认值为 DEFAULT，表示数据库的默认隔离级别</li><li>propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。</li><li>read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。</li><li>timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。</li><li>rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。</li><li>no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。</li></ul></li></ul></li><li><p>基于xml配置实例</p><ul><li><p>bean.xml</p><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;         xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;         xsi:schemaLocation=&quot;          http://www.springframework.org/schema/beans          http://www.springframework.org/schema/beans/spring-beans.xsd          http://www.springframework.org/schema/tx          http://www.springframework.org/schema/tx/spring-tx.xsd          http://www.springframework.org/schema/aop          http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;      &lt;!--configure service layer--&gt;      &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.AccountServiceImpl&quot;&gt;          &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;      &lt;!-- 配置账户的持久层--&gt;      &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;</code></pre></li></ul></li></ol><pre><code>            &lt;!-- 配置数据源--&gt;            &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;                &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;                &lt;property name=&quot;password&quot; value=&quot;HotteMYSQL&quot;&gt;&lt;/property&gt;            &lt;/bean&gt;            &lt;!--Declarative transaction management--&gt;            &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;                &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;            &lt;/bean&gt;            &lt;!--configure transaction advice--&gt;            &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;                &lt;tx:attributes&gt;                    &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt;                    &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;&gt;&lt;/tx:method&gt;                &lt;/tx:attributes&gt;            &lt;/tx:advice&gt;            &lt;!--configure pointcut expression--&gt;            &lt;aop:config&gt;                &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;                &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;            &lt;/aop:config&gt;        &lt;/beans&gt;- IAccountDao        public interface IAccountDao &#123;            /**             * 根据Id查询账户             * @param accountId             * @return             */            Account findAccountById(Integer accountId);            /**             * 根据名称查询账户             * @param accountName             * @return             */            Account findAccountByName(String accountName);            /**             * 更新账户             * @param account             */            void updateAccount(Account account);        &#125;- AccountDaoImpl        public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao &#123;            @Override            public Account findAccountById(Integer accountId) &#123;                List&lt;Account&gt; accounts = super.getJdbcTemplate().query(&quot;select * from account where id = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId);                return accounts.isEmpty()?null:accounts.get(0);            &#125;            @Override            public Account findAccountByName(String accountName) &#123;                List&lt;Account&gt; accounts = super.getJdbcTemplate().query(&quot;select * from account where name = ?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName);                if(accounts.isEmpty())&#123;                    return null;                &#125;                if(accounts.size()&gt;1)&#123;                    throw new RuntimeException(&quot;结果集不唯一&quot;);                &#125;                return accounts.get(0);            &#125;            @Override            public void updateAccount(Account account) &#123;                super.getJdbcTemplate().update(&quot;update account set name=?,money=? where id=?&quot;,account.getName(),account.getMoney(),account.getId());            &#125;        &#125;- Accont        public class Account implements Serializable &#123;            private Integer id;            private String name;            private Float money;            public Integer getId() &#123;                return id;            &#125;            public void setId(Integer id) &#123;                this.id = id;            &#125;            public String getName() &#123;                return name;            &#125;            public void setName(String name) &#123;                this.name = name;            &#125;            public Float getMoney() &#123;                return money;            &#125;            public void setMoney(Float money) &#123;                this.money = money;            &#125;            @Override            public String toString() &#123;                return &quot;Account&#123;&quot; +                        &quot;id=&quot; + id +                        &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                        &quot;, money=&quot; + money +                        &#39;&#125;&#39;;            &#125;        &#125;- IAccountService        /**         * Service layer interface of the account         */        public interface IAccountService &#123;            /**             * query account information by id             * @param accountId             * @return             */            Account findAccountById(Integer accountId);            /**             * transfer             * @param sourceName    transfer out account             * @param targetName    transfer to account             * @param Money     transfer amount             */            void transfer(String sourceName, String targetName, Float Money);        &#125;- AccountServiceImpl        public class AccountServiceImpl implements IAccountService&#123;            private IAccountDao accountDao;            public void setAccountDao(IAccountDao accountDao) &#123;                this.accountDao = accountDao;            &#125;            @Override            public Account findAccountById(Integer accountId) &#123;                return accountDao.findAccountById(accountId);            &#125;            @Override            public void transfer(String sourceName, String targetName, Float money) &#123;                System.out.println(&quot;transfer....&quot;);                //2.1根据名称查询转出账户                Account source = accountDao.findAccountByName(sourceName);                //2.2根据名称查询转入账户                Account target = accountDao.findAccountByName(targetName);                //2.3转出账户减钱                source.setMoney(source.getMoney()-money);                //2.4转入账户加钱                target.setMoney(target.getMoney()+money);                //2.5更新转出账户                accountDao.updateAccount(source);                        int i=1/0;                //2.6更新转入账户                accountDao.updateAccount(target);            &#125;        &#125;- AccountServiceTest        @RunWith(SpringJUnit4ClassRunner.class)        @ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)        public class AccountServiceTest &#123;            @Autowired            private  IAccountService as;            @Test            public  void testTransfer()&#123;                as.transfer(&quot;aaa&quot;,&quot;bbb&quot;,100f);            &#125;        &#125;</code></pre><ol start="3"><li>Spring 中基于注解的声明式事务控制配置步骤<ul><li>1 ) 配置事务管理器</li><li>2 ) 开启spring对注解事务的支持</li><li>3 ) 在需要事务支持的地方使用@Transactional注解</li></ul></li></ol><h3 id="（二）、编程式事务管理"><a href="#（二）、编程式事务管理" class="headerlink" title="（二）、编程式事务管理"></a>（二）、编程式事务管理</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring学习笔记（十一）事务管理&quot;&gt;&lt;a href=&quot;#Spring学习笔记（十一）事务管理&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记（十一）事务管理&quot;&gt;&lt;/a&gt;Spring学习笔记（十一）事务管理&lt;/h1&gt;&lt;h2 id=&quot;十</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89JdbcTemplate/"/>
    <id>http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89JdbcTemplate/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring学习笔记（十）JdbcTemplate"><a href="#Spring学习笔记（十）JdbcTemplate" class="headerlink" title="Spring学习笔记（十）JdbcTemplate"></a>Spring学习笔记（十）JdbcTemplate</h1><h2 id="十、Jdbc-Template"><a href="#十、Jdbc-Template" class="headerlink" title="十、Jdbc Template"></a>十、Jdbc Template</h2><ol><li><p>编码方式</p><ul><li><p>pom.xml</p><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;           xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;      &lt;groupId&gt;com.greyson&lt;/groupId&gt;      &lt;artifactId&gt;jdbctTemplates&lt;/artifactId&gt;      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;      &lt;packaging&gt;jar&lt;/packaging&gt;      &lt;dependencies&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-context&lt;/artifactId&gt;              &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;              &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;              &lt;version&gt;5.0.2.RELEASE &lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;mysql&lt;/groupId&gt;              &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;              &lt;version&gt;5.1.6&lt;/version&gt;          &lt;/dependency&gt;      &lt;/dependencies&gt;</code></pre></li></ul></li></ol><pre><code>        &lt;/project&gt;- Account        /**         * Account domain class         *         */        public class Account implements Serializable &#123;            private Integer Id;            private String name;            private Float money;            public Integer getId() &#123;                return Id;            &#125;            public void setId(Integer id) &#123;                Id = id;            &#125;            public String getName() &#123;                return name;            &#125;            public void setName(String name) &#123;                this.name = name;            &#125;            public Float getMoney() &#123;                return money;            &#125;            public void setMoney(Float money) &#123;                this.money = money;            &#125;            @Override            public String toString() &#123;                return &quot;Account&#123;&quot; +                        &quot;Id=&quot; + Id +                        &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                        &quot;, money=&quot; + money +                        &#39;&#125;&#39;;            &#125;        &#125;- JdbcTemplateDemo        /**         * The Basic Usage of JdbcTemplate         */        public class JdbcTemplateDemo &#123;            public static void main(String[] args) &#123;                // prepare dataSource                DriverManagerDataSource dataSource = new DriverManagerDataSource();                dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);                dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/eesy&quot;);                dataSource.setUsername(&quot;root&quot;);                dataSource.setPassword(&quot;HotteMYSQL&quot;);                // 1. create the object of JdbcTemplate                JdbcTemplate jdbcTemplate = new JdbcTemplate();                jdbcTemplate.setDataSource(dataSource);                // 2. execute operation                jdbcTemplate.execute(&quot;insert into  account(name, money)values(&#39;aaa&#39;, 1000)&quot;);            &#125;        &#125;</code></pre><ol start="2"><li><p>配置方式</p><p> 添加配置文件<code>ApplicationContext.xml</code>以及修改<code>JdbcTemplateDemo</code></p><ul><li><p>ApplicationContext.xml</p><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;      &lt;!-- congigure JdbcTemplate--&gt;      &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;      &lt;!--configure dataSource--&gt;      &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;          &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;          &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt;          &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;          &lt;property name=&quot;password&quot; value=&quot;HotteMYSQL&quot;&gt;&lt;/property&gt;      &lt;/bean&gt;  &lt;/beans&gt;</code></pre></li><li><p>JdbcTemplateDemo2</p><pre><code>  /**   * The Basic Usage of JdbcTemplate   */  public class JdbcTemplateDemo &#123;      public static void main(String[] args) &#123;          // prepare dataSource          DriverManagerDataSource dataSource = new DriverManagerDataSource();          dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);          dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/eesy&quot;);          dataSource.setUsername(&quot;root&quot;);          dataSource.setPassword(&quot;HotteMYSQL&quot;);          // 1. create the object of JdbcTemplate          JdbcTemplate jdbcTemplate = new JdbcTemplate();          jdbcTemplate.setDataSource(dataSource);          // 2. execute operation          jdbcTemplate.execute(&quot;insert into  account(name, money)values(&#39;aaa&#39;, 1000)&quot;);      &#125;  &#125;</code></pre></li></ul></li></ol><h1 id="Spring学习笔记（十一）事务管理"><a href="#Spring学习笔记（十一）事务管理" class="headerlink" title="Spring学习笔记（十一）事务管理"></a><a href="Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86.md">Spring学习笔记（十一）事务管理</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring学习笔记（十）JdbcTemplate&quot;&gt;&lt;a href=&quot;#Spring学习笔记（十）JdbcTemplate&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记（十）JdbcTemplate&quot;&gt;&lt;/a&gt;Spring学习笔记（</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9F%BA%E4%BA%8Exml%E7%9A%84IOC%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2021/01/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9F%BA%E4%BA%8Exml%E7%9A%84IOC%E6%A1%88%E4%BE%8B/</id>
    <published>2021-01-17T06:58:11.000Z</published>
    <updated>2021-01-17T06:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring学习笔记（四）基于xml的IOC案例"><a href="#Spring学习笔记（四）基于xml的IOC案例" class="headerlink" title="Spring学习笔记（四）基于xml的IOC案例"></a>Spring学习笔记（四）基于xml的IOC案例</h1><h2 id="四、基于-xml-的-IOC-案例"><a href="#四、基于-xml-的-IOC-案例" class="headerlink" title="四、基于 xml 的 IOC 案例"></a>四、基于 xml 的 IOC 案例</h2><ol><li><p>创建数据库</p><pre><code> create table account(     id int primary key auto_increment,     name varchar(40),     money float )character set utf8 collate utf8_general_ci; insert into account(name,money) values(&#39;aaa&#39;,1000); insert into account(name,money) values(&#39;bbb&#39;,1000); insert into account(name,money) values(&#39;ccc&#39;,1000);</code></pre></li><li><p>文件结构如下</p><p> <img src="Untitled-b8f378d2-1d05-4829-918a-6674b2da7ca7.png"></p></li><li><p>创建接口</p><ul><li><p>IAccountDao</p><pre><code>  public interface IAccountDao &#123;      /**       * 查询所有       * @return       */      List&lt;Account&gt; findAllAccount();      /**       * 查询一个       * @return       */      Account findAccountById(Integer accountId);      /**       * 保存       * @param account       */      void saveAccount(Account account);      /**       * 更新       * @param account       */      void updateAccount(Account account);      /**       * 删除       * @param accountId       */      void deleteAccount(Integer accountId);  &#125;</code></pre></li><li><p>IAccountService</p><pre><code>  public interface IAccountService &#123;      /**       * 查询所有       * @return       */      List&lt;Account&gt; findAllAccount();      /**       * 查询一个       * @return       */      Account findAccountById(Integer accountId);      /**       * 保存       * @param account       */      void saveAccount(Account account);      /**       * 更新       * @param account       */      void updateAccount(Account account);      /**       * 删除       * @param accountId       */      void deleteAccount(Integer accountId);  &#125;</code></pre></li></ul></li><li><p>创建实现类</p><ul><li><p>AccountDaoImpl</p><pre><code>  public class AccountDaoImpl implements IAccountDao &#123;      private QueryRunner runner;      public void setRunner(QueryRunner runner) &#123;          this.runner = runner;      &#125;      public List&lt;Account&gt; findAllAccount() &#123;          try&#123;              return runner.query(&quot;select * from account&quot;, new BeanListHandler&lt;Account&gt;(Account.class));          &#125; catch (Exception e) &#123;              throw new RuntimeException(e);          &#125;      &#125;      public Account findAccountById(Integer accountId) &#123;          try&#123;              return runner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class),accountId);          &#125; catch (Exception e) &#123;              throw new RuntimeException(e);          &#125;      &#125;      public void saveAccount(Account account) &#123;          try&#123;              runner.update(&quot;insert into account(name, money) values(?,?)&quot;, account.getName(),account.getMoney());          &#125; catch (Exception e) &#123;              throw new RuntimeException(e);          &#125;      &#125;      public void updateAccount(Account account) &#123;          try&#123;              runner.update(&quot;update account set name = ?, money = ? where id = ?&quot;, account.getName(),account.getMoney(),account.getId());          &#125; catch (Exception e) &#123;              throw new RuntimeException(e);          &#125;      &#125;      public void deleteAccount(Integer accountId) &#123;          try&#123;              runner.update(&quot;delete from account where id = ?&quot;, accountId);          &#125; catch (Exception e) &#123;              throw new RuntimeException(e);          &#125;</code></pre></li><li><p>AccountServiceImpl</p><pre><code>  public class AccountServiceImpl implements IAccountService &#123;      private IAccountDao accountDao;      public void setAccountDao(IAccountDao accountDao) &#123;          this.accountDao = accountDao;      &#125;      public List&lt;Account&gt; findAllAccount() &#123;          return accountDao.findAllAccount();      &#125;      public Account findAccountById(Integer accountId) &#123;          return accountDao.findAccountById(accountId);      &#125;      public void saveAccount(Account account) &#123;          accountDao.saveAccount(account);      &#125;      public void updateAccount(Account account) &#123;          accountDao.updateAccount(account);      &#125;      public void deleteAccount(Integer accountId) &#123;          accountDao.deleteAccount(accountId);      &#125;  &#125;</code></pre></li></ul></li><li><p> 创建账户实体类</p></li></ol><ul><li><p>Account</p><pre><code>  public class Account implements Serializable &#123;      private Integer id;      private String name;      private Float money;      public void setId(Integer id) &#123;          this.id = id;      &#125;      public void setName(String name) &#123;          this.name = name;      &#125;      public void setMoney(Float money) &#123;          this.money = money;      &#125;      public Integer getId() &#123;          return id;      &#125;      public String getName() &#123;          return name;      &#125;      public Float getMoney() &#123;          return money;      &#125;      @Override      public String toString() &#123;          return &quot;Account&#123;&quot; +                  &quot;id=&quot; + id +                  &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                  &quot;, money=&quot; + money +                  &#39;&#125;&#39;;      &#125;  &#125;</code></pre></li></ul><ol start="6"><li>创建测试类</li></ol><ul><li><p>AccountServiceTest</p><pre><code>  public class AccountServiceTest &#123;      @Test      public void testFindAll() &#123;          // 1.获取容器          ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);          // 2.得到业务层对象          IAccountService iAccountService = applicationContext.getBean(&quot;accountService&quot;,IAccountService.class);          // 3.执行方法          List&lt;Account&gt; accounts = iAccountService.findAllAccount();          for (Account account : accounts) &#123;              System.out.println(account);          &#125;      &#125;      @Test      public void testFindOne() &#123;          // 1.获取容器          ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);          // 2.得到业务层对象          IAccountService iAccountService = applicationContext.getBean(&quot;accountService&quot;,IAccountService.class);          // 3.执行方法          Account account = iAccountService.findAccountById(1);          System.out.println(account);      &#125;      @Test      public void testSave() &#123;          Account account = new Account();          account.setName(&quot;test&quot;);          account.setMoney(12345f);          // 1.获取容器          ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);          // 2.得到业务层对象          IAccountService iAccountService = applicationContext.getBean(&quot;accountService&quot;,IAccountService.class);          // 3.执行方法          iAccountService.saveAccount(account);      &#125;      @Test      public void testUpdate() &#123;          // 1.获取容器          ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);          // 2.得到业务层对象          IAccountService iAccountService = applicationContext.getBean(&quot;accountService&quot;,IAccountService.class);          // 3.执行方法          Account account = iAccountService.findAccountById(4);          account.setMoney(23456f);          iAccountService.updateAccount(account);      &#125;      @Test      public void testDelete() &#123;          // 1.获取容器          ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);          // 2.得到业务层对象          IAccountService iAccountService = applicationContext.getBean(&quot;accountService&quot;,IAccountService.class);          // 3.执行方法          iAccountService.deleteAccount(4);      &#125;  &#125;</code></pre></li></ul><ol start="7"><li><p>配置 bean.xml</p> <?xml version="1.0" encoding="UTF-8"?><p> &lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;">http://www.springframework.org/schema/beans&quot;</a></p><pre><code>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--配置Service--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.greyson.service.impl.AccountServiceImpl&quot;&gt;     &lt;!--注入dao--&gt;     &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置dao--&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.greyson.dao.impl.AccountDaoImpl&quot;&gt;     &lt;!--注入runner--&gt;     &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置runner--&gt; &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;     &lt;!--注入数据源--&gt;     &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;     &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;     &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt;     &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;     &lt;property name=&quot;password&quot; value=&quot;HotteMYSQL&quot;&gt;&lt;/property&gt; &lt;/bean&gt;</code></pre> </beans># [Spring学习笔记（五）基于注解的IOC](Spring学习笔记（五）基于注解的IOC.md)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring学习笔记（四）基于xml的IOC案例&quot;&gt;&lt;a href=&quot;#Spring学习笔记（四）基于xml的IOC案例&quot; class=&quot;headerlink&quot; title=&quot;Spring学习笔记（四）基于xml的IOC案例&quot;&gt;&lt;/a&gt;Spring学习笔记（四）基</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AQS 队列初始化 —— 源码分析</title>
    <link href="http://example.com/2020/02/28/AQS-%E9%98%9F%E5%88%97%E5%88%9D%E5%A7%8B%E5%8C%96-%E2%80%94%E2%80%94-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2020/02/28/AQS-%E9%98%9F%E5%88%97%E5%88%9D%E5%A7%8B%E5%8C%96-%E2%80%94%E2%80%94-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-02-28T13:46:51.000Z</published>
    <updated>2021-01-17T06:32:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设如下情景：线程 T1 已经获取锁 ， 线程 T2 此时进来 ， 首先判断锁的状态 ， 锁已经被占有，则入队。</p><p>Node 类的设计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">volatile Node prev;</span><br><span class="line">  volatile Node next;</span><br><span class="line">volatile Thread thread;</span><br><span class="line">int ws;      &#x2F;&#x2F; 当前 Node 的状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="入队过程："><a href="#入队过程：" class="headerlink" title="入队过程："></a>入队过程：</h2><ol><li><p>根据线程来实例化一个 Node</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据当前线程实例化一个Node</span><br><span class="line">        Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">        &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 1. 将尾部赋给一个临时变量，注意此时tail为空，因为tail此时还没有指向Node对象</span><br><span class="line">         * 2. tail &#x3D;&#x3D; null，因此执行 enq(node) 方法，这个node是创建的当前线程的node</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Node pred &#x3D; tail;</span><br><span class="line">        if (pred !&#x3D; null) &#123;</span><br><span class="line">            node.prev &#x3D; pred;</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next &#x3D; node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>再次实例化一个 Thread 为 null 的 Node ， 我们暂时称其为 NullThreadNode</p><p>注意：AQS队列中队头所指向的Node的Thread永远为空</p></li><li><p>把 NullThreadNode 设置为 AQS 队列的头部和尾部</p></li><li><p>队列初始化</p></li><li><p>维护链表关系（入队）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">        &#x2F;&#x2F; 死循环判断</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 第一次循环：</span><br><span class="line">             *  tail赋值给临时变量t， 注意此时tail仍然是null, 进入if块</span><br><span class="line">             * 调用compareAndSetHead(new Node()) 创建了一个新的节点 ，这个节点的结构如下：</span><br><span class="line">             *         Node() &#123;    &#x2F;&#x2F; Used to establish initial head or SHARED marker</span><br><span class="line">             *         &#125;</span><br><span class="line">             *   该节点为空，也就是我们称为 NullThreadNode 的节点</span><br><span class="line">             *   此时队列里有了第一个Node</span><br><span class="line">             *&#x2F;</span><br><span class="line">            Node t &#x3D; tail;</span><br><span class="line">            if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    tail &#x3D; head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * 第二次循环：在第一次循环时head赋给了tail,此时tail 不为空，</span><br><span class="line">                 * 进入else块，将线程T1入队，也就是维护链表关系</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                node.prev &#x3D; t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next &#x3D; node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>自旋一次 ，判断能不能拿到锁</p><p>注意此处，只有队列中第二个 Node 才有自旋的资格，第三个及其以后的 Node 很显然前边有优先级更高的线程在等待锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted &#x3D; false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p &#x3D; node.predecessor();</span><br><span class="line">&#x2F;&#x2F; 判断上一个节点是否是头部，即当前节点为队列中第二个节点，tryAcquire()尝试获取锁</span><br><span class="line">                if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">                 *  判断在一次自旋加锁失败后是否需要睡眠</span><br><span class="line">                 * 自旋第一次时shouldParkAfterFailedAcquire(p, node)返回false, 不会进入if块</span><br><span class="line">                 * 自旋第二次时，shouldParkAfterFailedAcquire(p, node)返回true,</span><br><span class="line">                 * 此时进入parkAndCheckInterrupt()方法，此时线程阻塞在 parkAndCheckInterrupt()</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>shouldParkAfterFailedAcquire()</code>  源码如下：</p><p>pred 是上一个节点，在此时也就是队列中的第一个节点，即上面我们称之为 NullThreadNode 的节点，每个节点的waitStatus初始值为0，SIGNAL默认值为1。此方法在第一次被调用时会进入 else 块，将 ws 设置为 -1，在第二次被调用时ws == SIGNAL，返回true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws &#x3D; pred.waitStatus;     &#x2F;&#x2F; ws默认值为0，SIGNAL默认值为1</span><br><span class="line">        if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">            return true;</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#x2F;&#x2F; CAS设置ws</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>线程阻塞在 <code>parkAndCheckInterrupt()</code> 方法中</p></li></ol><p>上述就是一个队列的入队过程，我们再进一步研究下，如果同时有大量的线程并发执行企图获取锁的情况是怎样的呢？</p><p>我们假设此时还要一个线程 T3 企图获取锁，我们只关注第七个步骤，在执行到 <code>shouldParkAfterFailedAcquire()</code> 方法时，在第一次被调用时判断 ws = 0（注意 ws 是上一个节点的waitStatus，此时也就是第二个节点的ws），因此执行 else 块并且将 ws 设置为 -1，在第二次循环时ws 已经是 -1 ，所以执行第一个 if 块，返回true；线程 T3 阻塞。</p><p>多个线程的执行过程同理，即重复上述步骤。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;假设如下情景：线程 T1 已经获取锁 ， 线程 T2 此时进来 ， 首先判断锁的状态 ， 锁已经被占有，则入队。&lt;/p&gt;
&lt;p&gt;Node 类的设计：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Node &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	volatile Node prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  volatile Node next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	volatile Thread thread;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int ws;      &amp;#x2F;&amp;#x2F; 当前 Node 的状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="高并发" scheme="http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
